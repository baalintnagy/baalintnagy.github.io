<!doctype html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Formulator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/asciimathml/2.2.7/ASCIIMathML.min.js"></script>
  </head>
  <body>
    <div class="container mt-4">
      <h1>Formula cleaner</h1>
      <hr>

      <form>
        <div class="form-group mb-3">
          <label for="formulaInput">Input:</label>
          <textarea class="form-control" id="formulaInput" rows="10"></textarea>
        </div>
        <div class="form-group mb-3">
          <label id ="formulaOutputLabel" for="formulaOutput">Output:</label>
          <textarea class="form-control" id="formulaOutput" rows="10"></textarea>
        </div>
      </form>
    </div>

    <script>
        // Get references to the input and output elements
        const formulaInput = document.getElementById('formulaInput');
        const formulaOutput = document.getElementById('formulaOutput');
        const formulaOutputLabel = document.getElementById('formulaOutputLabel');

        const FORMULA_OUTPUT_LABEL_PREFIX = "Output: ";

        function parseAndConvertHTML(input) {
          // Step 1: Parse the input string as HTML
          const parser = new DOMParser();
          const doc = parser.parseFromString(input, 'text/html');
          
          // Step 2: Replace block-level elements with a space before getting the text content
          const blockElements = ['div', 'p', 'br', 'li', 'td', 'th', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol'];
          blockElements.forEach(tag => {
              doc.querySelectorAll(tag).forEach(el => el.replaceWith(' ' + el.textContent + ' '));
          });

          // Step 3: Strip all HTML tags and get text content only
          let plainText = doc.body.textContent || "";

          // Step 4: Clean up line breaks, excess whitespace, etc.
          plainText = plainText.replace(/\s+/g, ' ').trim(); // Remove excess whitespace and newlines
          
          // Return the final result as a single line string
          return plainText;
        }


        function processPlain(input) {
          let cleanedData = input
            .replace(/\s+/g, ' ') // Replace multiple spaces, newlines with a single space
            .replace(/-\s/g, '-') // Handle broken hyphenated expressions
            .replace(/\s=\s/g, '='); // Ensure no spaces around equals
      
          // Guess missing symbols (simple guesses, adjust as needed)
          cleanedData = cleanedData.replace(/([a-zA-Z])(\d)/g, '$1_$2'); // Convert variables with numbers to subscript notation (x2 -> x_2)
      
          // Handle common math symbols
          const symbolReplacements = [
            { unicode: /∫/g, asciiMath: 'int' }, // Integral sign
            { unicode: /∑/g, asciiMath: 'sum' }, // Summation sign
            { unicode: /∏/g, asciiMath: 'prod' }, // Product sign
            { unicode: /√/g, asciiMath: 'sqrt' }, // Square root
            { unicode: /∞/g, asciiMath: 'infty' }, // Infinity
            { unicode: /≤/g, asciiMath: '<=' }, // Less than or equal to
            { unicode: /≥/g, asciiMath: '>=' }, // Greater than or equal to
            { unicode: /≠/g, asciiMath: '!=' }, // Not equal
            { unicode: /±/g, asciiMath: '+-' }, // Plus-minus
            { unicode: /×/g, asciiMath: '*' }, // Multiplication symbol
            { unicode: /÷/g, asciiMath: '/' }, // Division symbol
            { unicode: /π/g, asciiMath: 'pi' }, // Pi
            { unicode: /θ/g, asciiMath: 'theta' }, // Theta
            { unicode: /α/g, asciiMath: 'alpha' }, // Alpha
            { unicode: /β/g, asciiMath: 'beta' }, // Beta
            { unicode: /→/g, asciiMath: '->' }, // Right arrow
            { unicode: /←/g, asciiMath: '<-' }, // Left arrow
          ];
      
          // Replace symbols in the cleaned data
          symbolReplacements.forEach(symbol => {
            cleanedData = cleanedData.replace(symbol.unicode, symbol.asciiMath);
          });

          return cleanedData;
        }

        





      
        // Add an event listener to update output when typing occurs in the input
        formulaInput.addEventListener('input', function () {
          // Output the cleaned and converted data
          //formulaOutput.value = processPlain(formulaInput.value);
        });

        formulaInput.addEventListener('focus', function(event) {
          formulaInput.value = '';
        });

        formulaInput.addEventListener('paste', function(event) {
          event.preventDefault();
          const plainText = (event.clipboardData || window.clipboardData).getData('text/plain');
          const htmlData = (event.clipboardData || window.clipboardData).getData('text/html');

            // Check what data is available
          if (htmlData) {
            // If HTML is available, show it with formatting
            formulaInput.value = htmlData;
            formulaOutput.value = parseAndConvertHTML(htmlData);
            formulaOutputLabel.textContent = FORMULA_OUTPUT_LABEL_PREFIX + 'HTML:';            
          } else {
            // If only plain text is available, append it to the output div
            formulaInput.value = plainText;
            formulaOutput.value = processPlain(plainText);
            formulaOutputLabel.textContent = FORMULA_OUTPUT_LABEL_PREFIX + 'plain text:';            
          }
        });
      </script>
      

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  </body>
</html>
